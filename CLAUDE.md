# CLAUDE.md — Lending Club Loan Portfolio Investment Analysis Tool

## Project Overview

Build an interactive Streamlit dashboard for analyzing a portfolio of ~2.2M Lending Club consumer loans. The tool lets an investor filter by pool strata, view credit/performance metrics, project cash flows under purchase price assumptions, and compare base/stress/upside scenarios with IRR calculations.

This project has three functional parts:
1. **Portfolio Analytics** — Pool stratifications, credit metrics, performance metrics, delinquency transitions (EXISTING — do not rewrite)
2. **Cash Flow Projection & IRR** — Monthly projected cash flows at pool level, IRR at a purchase price, price solver for target IRR
3. **Scenario Analysis** — Base/stress/upside comparison with user-adjustable multiplicative shifts

All three parts surface through a single Streamlit app (`app.py`) with sidebar filters and three tabs.

---

## Environment Setup

- Virtual environment named `.env` in project root
- Setup: `python -m venv .env && source .env/bin/activate && pip install -r requirements.txt`
- Dependencies listed in `requirements.txt`

---

## Tech Stack

- **Language**: Python 3.11+, 4-space indentation, type hints on all function signatures
- **Core**: pandas, numpy, scipy (`brentq`), numpy_financial (`npf.irr`)
- **Dashboard**: streamlit, plotly
- **Database**: sqlite3
- **Testing**: pytest

---

## MCP Tools Available

| MCP | Purpose | When to Use |
|-----|---------|-------------|
| **sequential-thinking** | Step-by-step reasoning | ALL financial math |
| **context7** | Library docs | pandas/numpy/streamlit/scipy API details |
| **serena** | Semantic code navigation | Multi-file refactors, tracing calls |
| **playwright** | Browser automation | Dashboard UI validation ONLY |
| **sqlite** | Database queries | Direct queries against `data/loans.db` |
| **github** | GitHub API integration | Pushing code, creating branches, opening PRs, managing issues and releases via GitHub's official MCP server |

**Rule**: Use sequential-thinking before implementing any financial formula.

### GitHub MCP Setup
The GitHub MCP requires a Personal Access Token (PAT) with `repo` scope. Add it to Claude Code:
```
claude mcp add github --transport http https://api.githubcopilot.com/mcp/ -H "Authorization: Bearer YOUR_GITHUB_PAT"
```
Verify with: `claude mcp list`
Inside Claude Code, run `/mcp` to confirm the github server shows as connected.

---

## File Structure

```
lending-club-tool/
├── .env/                          ← virtual environment (in .gitignore)
├── .claude/
│   ├── agents/                    ← 5 specialized agents (see Agents table)
│   │   ├── dashboard-reviewer.md
│   │   ├── data-integrity.md
│   │   ├── doc-sync.md
│   │   ├── financial-validator.md
│   │   └── github-manager.md
│   ├── skills/                    ← 3 domain-knowledge skills (see Skills table)
│   └── commands/                  ← 8 reusable commands (see Commands table)
├── CLAUDE.md                      ← this file
├── requirements.txt
├── data/
│   ├── accepted_2007_to_2018Q4.csv ← RAW (~2.2M loans, input for export script)
│   └── loans.db                   ← SQLite database (generated by export script)
├── docs/
│   ├── coding_project.md          ← original assessment instructions
│   ├── user_guide.md              ← setup, how to run, codebase walkthrough
│   ├── calculations.md            ← every formula, metric definition, assumptions
│   └── data_cleaning.md           ← cleaning decisions, row count stats
├── src/
│   ├── __init__.py
│   ├── amortization.py            ← calc_amort() and helpers (EXISTING)
│   ├── portfolio_analytics.py     ← credit/performance metrics, transitions, display functions
│   ├── cashflow_engine.py         ← pool-level projections, IRR, price solver
│   └── scenario_analysis.py       ← base/stress/upside scenario builder
├── app.py                         ← Streamlit dashboard (sidebar + 3 tabs)
├── tests/
│   ├── test_amortization.py
│   ├── test_portfolio_analytics.py
│   ├── test_cashflow_engine.py
│   └── test_scenario_analysis.py
└── scripts/
    ├── analysis.ipynb             ← original Jupyter notebook (reference only)
    └── export_to_sqlite.py        ← data cleaning pipeline → loans.db
```

Each module in `src/` must be independently importable. No global state. Functions receive data via arguments and return results.

---

## Agents

| Agent | File | Model | Purpose |
|-------|------|-------|---------|
| Financial Validator | `.claude/agents/financial-validator.md` | opus | Validates financial formulas against known test cases |
| Dashboard Reviewer | `.claude/agents/dashboard-reviewer.md` | sonnet | End-to-end Streamlit UI testing via Playwright |
| Doc Sync | `.claude/agents/doc-sync.md` | sonnet | Verifies docs stay accurate when code changes |
| Data Integrity | `.claude/agents/data-integrity.md` | sonnet | Validates SQLite database quality |
| GitHub Manager | `.claude/agents/github-manager.md` | sonnet | Manages repo — commits with conventional messages, feature branches, PRs, releases. Uses GitHub MCP for remote ops. |

---

## Skills

**Read the relevant skill BEFORE implementing code in that area.**

| Skill | File | When to Read |
|-------|------|-------------|
| Lending Math | `.claude/skills/lending-math/SKILL.md` | Before ANY financial formula work |
| Data Schema | `.claude/skills/data-schema/SKILL.md` | When writing SQL, building filters, debugging columns |
| Streamlit Patterns | `.claude/skills/streamlit-patterns/SKILL.md` | When building or modifying `app.py` |

---

## Commands

| Command | Purpose |
|---------|---------|
| `/project:run-tests` | Run `pytest tests/ -v` with failure diagnosis |
| `/project:validate-math` | Verify financial formulas against lending-math skill |
| `/project:check-data` | Quick SQLite integrity checks |
| `/project:sync-docs` | Compare docs against code for drift |
| `/project:project-cashflows` | End-to-end pipeline smoke test |
| `/project:scenario-compare` | Run 3-scenario comparison with verification |
| `/project:launch-dashboard` | Start Streamlit with checks |
| `/project:add-strata-filter` | Add a new sidebar filter column |

---

## Domain Terminology

> **For detailed formulas, worked examples, and edge cases, read `.claude/skills/lending-math/SKILL.md`.**
> **For full column reference and strata definitions, read `.claude/skills/data-schema/SKILL.md`.**

Key rates: SMM, CPR, MDR, CDR (conditional, annualized), Loss Severity, Recovery Rate, WAC, WAM, WALA, IRR. All formulas with derivations are in `docs/calculations.md` and the lending-math skill.

- **MDR (Monthly Default Rate, observed)**: For a given calendar month M: `MDR_M = defaults_in_month_M / performing_balance_at_start_of_month_M`. This parallels SMM for prepayments.
- **CDR (Conditional Default Rate)**: `CDR = 1 - (1 - avg_MDR)^12` where `avg_MDR` is the average of 12 trailing monthly MDRs (Apr 2018 – Mar 2019). This is the PRIMARY rate used in cash flow projections. Uses the dv01 conditional methodology.
- **Cumulative Default Rate (reference only)**: `cumulative_default_rate = sum(defaulted_upb) / sum(funded_amnt)`. Raw lifetime default rate. Displayed for reference but NOT used in cash flow engine. Do NOT call this "CDR" — CDR refers only to the conditional (annualized) rate.
- **MDR (Monthly Default Rate, for projections)**: `MDR = 1 - (1 - CDR)^(1/12)`. The round-trip is: observe monthly MDRs → average → annualize to CDR → cash flow engine converts back to MDR via this formula.

---

## Data Details

### Source
Lending Club: `accepted_2007_to_2018Q4.csv` (~2.2M loans, 151 columns). Snapshot as of March 2019.

### Data Cleaning
Full cleaning pipeline with 19 steps is documented in `docs/data_cleaning.md`. Key points:
- **Column whitelist** (29 raw columns kept): `id`, `loan_status`, `funded_amnt`, `int_rate`, `term`, `installment`, `grade`, `sub_grade`, `purpose`, `addr_state`, `home_ownership`, `issue_d`, `last_pymnt_d`, `next_pymnt_d`, `last_credit_pull_d`, `out_prncp`, `total_rec_prncp`, `total_rec_int`, `total_rec_late_fee`, `last_pymnt_amnt`, `recoveries`, `collection_recovery_fee`, `fico_range_high`, `fico_range_low`, `last_fico_range_high`, `last_fico_range_low`, `dti`, `dti_joint`, `annual_inc`, `annual_inc_joint`, `application_type`
- **Engineered columns** (~17): `term_months`, `maturity_month`, `original_fico`, `latest_fico`, `dti_clean`, `annual_inc_clean`, `joint_app_flag`, `issue_quarter`, `issue_month_year`, `upb_lost`, various reclassification flags
- `int_rate` stored as decimal (0.1078), not percentage

### Data Context — Backsolve Capability

This is a single point-in-time snapshot (March 2019). No monthly servicing tapes. However, we reconstruct approximate monthly loan statuses using backsolve logic because Lending Club's delinquency progression is deterministic:

- **Delinquent (0-30)**: `last_pymnt_d + 1 month` (missed payment month — Grace + Late 16-30 combined)
- **Late (31-120)**: `delinquent_month + 1 month`
- **Default/Charged Off**: `delinquent_month + 4 months` (~120 days, terminal)
- **Fully Paid**: `payoff_month = last_pymnt_d`

**5 transition states**: Current, Delinquent (0-30), Late (31-120), Charged Off (absorbing), Fully Paid (absorbing).

Key constraints: Current cannot skip to Charged Off or Late (31-120). Late (31-120) cannot cure. Charged Off and Fully Paid are terminal.

These reconstructed transitions are for display/analysis in Tab 1 only. The cash flow engine uses a constant annualized CDR.

---

## Function Reference

### Existing Functions — DO NOT MODIFY

Extracted from `scripts/analysis.ipynb`. Do not modify logic — only imports.

**`src/amortization.py`**:
- `calc_amort(df, ...) → pd.DataFrame` — Adds ~20 columns (orig_exp_*, last_pmt_*, next_pmt_*, updated_remaining_term, updated_maturity_date)
- Helpers: `calc_monthly_payment()`, `calc_balance()`, `calc_payment_num()`

**`src/portfolio_analytics.py`** (existing):
- `calculate_credit_metrics(df, strata_col) → pd.DataFrame` — Requires calc_amort columns. Returns origination + active metrics by strata. Includes "ALL" row.
- `calculate_performance_metrics(df, vintage_col='issue_quarter') → pd.DataFrame` — Requires calc_amort columns. Returns CPR, CDR, loss severity by vintage.
- `calculate_transition_matrix(df, strata_col=None) → pd.DataFrame` — Flow-based transition probabilities.

### Display Functions (in `src/portfolio_analytics.py`)

These are display-only, do NOT feed into the cash flow engine. They use only base DB columns (no calc_amort dependency).

- `reconstruct_loan_timeline(df) → pd.DataFrame` — Adds 12 columns: loan_age_months (capped at term_months), age_bucket, age_bucket_label, delinquent_month, late_31_120_month, default_month, payoff_month, delinquent_age, late_31_120_age, default_age, payoff_age, cured_from_late
- `get_loan_status_at_age(df, age) → pd.Series` — Vectorized status at a specific loan age. Priority: Charged Off > Fully Paid > Late (31-120) > Delinquent (0-30) > Current. Returns None for loans not yet at given age.
- `compute_age_transition_probabilities(df, bucket_size=6) → pd.DataFrame` — Empirical transition probabilities per 6-month age bucket. Returns age_bucket, from_status, to_*_pct columns, observation_count.
- `compute_pool_transition_matrix(df_current, age_probs) → dict` — Dollar-flow matrix from age-specific probabilities applied to current pool UPB. Returns aggregate_matrix, aggregate_matrix_pct, breakdown_by_age.
- `compute_default_timing(df, group_col=None) → pd.DataFrame` — Default timing distribution by loan age. Returns default_age_months, loan_count, upb_amount, pct_of_defaults, cumulative_pct.
- `compute_loan_age_status_matrix(df, bucket_size=6) → pd.DataFrame` — Cross-sectional status distribution at each age bucket. Returns age_bucket, total_loans, total_upb, pct_current, pct_fully_paid, pct_charged_off, pct_late_grace.

### Cash Flow Functions (in `src/cashflow_engine.py`)

- `compute_pool_assumptions(df_all, df_current) → dict` — Base-case CDR (conditional, 12-month trailing average MDR, annualized via dv01 methodology), CPR, loss severity. Requires `reconstruct_loan_timeline()` to have been called on `df_all` first (for `default_month` and `payoff_month` columns). Returns `{'cdr': float, 'cumulative_default_rate': float, 'avg_mdr': float, 'monthly_mdrs': list[float], 'cpr': float, 'loss_severity': float, 'recovery_rate': float}`. Where: `cdr` = conditional CDR (PRIMARY, used in cash flow projections); `cumulative_default_rate` = raw lifetime rate (display/reference only, NOT called CDR); `avg_mdr` = average monthly default rate (un-annualized, for display); `monthly_mdrs` = list of 12 individual monthly MDRs (for display, shows trend/volatility); `cpr` = single-month CPR from calc_amort (UNCHANGED); `loss_severity`, `recovery_rate` = unchanged.
- `compute_pool_characteristics(df_current) → dict` — Pool aggregates: {total_upb, wac, wam, monthly_payment}.
- `project_cashflows(pool_chars, cdr, cpr, loss_severity, purchase_price) → pd.DataFrame` — Monthly projection loop. Returns month, date, beginning_balance, defaults, loss, recovery, interest, scheduled_principal, prepayments, total_principal, ending_balance, total_cashflow.
- `calculate_irr(cashflows_df, pool_chars, purchase_price) → float` — Annualized IRR from projected cash flows.
- `solve_price(pool_chars, target_irr, cdr, cpr, loss_severity) → float` — Brentq solver for purchase price at target IRR. Bounds [0.50, 1.50].

### Scenario Functions (in `src/scenario_analysis.py`)

- `compute_base_assumptions(df_all, df_current) → dict` — Wrapper for compute_pool_assumptions.
- `build_scenarios(base_assumptions, stress_pct=0.15, upside_pct=0.15) → dict` — Multiplicative shifts. Stress: CDR×(1+pct), CPR×(1-pct). Upside: CDR×(1-pct), CPR×(1+pct). Loss severity FIXED.
- `compare_scenarios(pool_chars, scenarios, purchase_price) → pd.DataFrame` — Runs projections + IRR for each scenario.

---

## Streamlit Dashboard (`app.py`)

> **For detailed layout templates and styling, read `.claude/skills/streamlit-patterns/SKILL.md`.**

### Layout
Single page with sidebar + 3 tabs.

### Sidebar Controls
1. **Strata Type** dropdown: grade, term_months, purpose, addr_state, issue_quarter, or ALL
2. **Strata Value** dropdown: populated dynamically. Disabled if ALL.

Purchase Price, CDR/CPR overrides, and Stress/Upside % controls live on their respective tabs (Tab 2 and Tab 3).

### Display Format
All rates/prices displayed as **percentages to 2 decimal places** (e.g., 95.00%, 8.73%). Stored internally as decimals.

### Data Flow
1. User selects strata → query SQLite
2. Run `calc_amort()` on filtered data
3. Tab 1 uses ALL loans; Tabs 2 & 3 use ONLY Current loans with `last_pymnt_d == 2019-03-01`
4. CDR from ALL loans; CPR from Current March 2019 only; Loss severity from Charged Off subset
5. Tab 2 allows CDR/CPR/price overrides; Tab 3 has own price + stress/upside %

### Tab 1: Portfolio Metrics
- Credit metrics, performance metrics, transition matrix tables (existing functions)
- Age-Weighted Transition Matrix: heatmap + age bucket breakdown table
- Default Timing Curve: histogram + cumulative line (dual axis)
- Loan Age Status Distribution: stacked bar with toggles (monthly/6-month, count/UPB)

### Tab 2: Cash Flow Projection
- Show computed base assumptions as metric cards:
  - **CDR (Conditional, 12mo trailing)**: the annualized rate driving projections
  - **Cumulative Default Rate**: raw lifetime rate — shown in smaller text or tooltip as reference (do NOT label as "CDR")
  - **Avg MDR**: un-annualized monthly default rate for transparency
  - **CPR**: single-month from calc_amort (unchanged)
  - **Loss Severity** and **Recovery Rate**: unchanged
- Pool characteristics as metric cards
- User inputs: Purchase Price (%), CDR (%), CPR (%)
- IRR display, "Solve for Price" input
- Balance chart, stacked area chart, expandable monthly table

### Tab 3: Scenario Comparison
- Own Purchase Price (%), Stress/Upside % slider
- Scenario assumption table, IRR summary, bar chart, multi-line balance chart

---

## Coding Conventions

- PEP8, docstrings, type hints on all function signatures
- Vectorized NumPy/Pandas operations; `logging` for warnings (not `print()`)
- 2 decimal places for display; full precision internally
- No hardcoded file paths

---

## Testing

- `pytest tests/ -v` from project root
- Test files mirror src modules. See `tests/test_*.py` for all test cases.
- All 130 tests currently pass (57 portfolio_analytics, 73 other modules).
- `compute_pool_assumptions` CDR:
  - Create synthetic cohort: 1000 loans originated Jan 2017. In each of the 12 trailing months (Apr 2018 – Mar 2019), 5 loans default each month with $10K exposure each. Performing balance ~$8M/month. Verify avg_MDR ≈ $50K/$8M ≈ 0.625%/month, CDR = 1-(1-0.00625)^12 ≈ 7.24%
  - Zero defaults in all 12 months: all MDRs = 0, CDR = 0
  - Verify monthly_mdrs list has exactly 12 elements
  - Verify CDR round-trip: CDR → MDR via projection formula ≈ avg_mdr from observations
  - Verify cumulative_default_rate is also returned (different value from conditional CDR, and not labeled as CDR)

---

## Documentation

- `docs/calculations.md` — Every formula with variable definitions and assumptions
- `docs/data_cleaning.md` — Every cleaning step with rationale and row counts
- `docs/user_guide.md` — Setup, how to run, codebase overview

---

## Critical Rules

- **NEVER rewrite** `calc_amort()`, `calculate_credit_metrics()`, `calculate_performance_metrics()`, or `calculate_transition_matrix()`. Extracted from notebook — do not modify logic.
- **ALWAYS use sequential-thinking** MCP before implementing financial math.
- **ALWAYS read the relevant skill file** before writing code in that domain.
- **Cash flows and scenarios operate on Current loans with March 2019 last payment date ONLY.**
- **CDR is computed from ALL loans in the cohort** using the dv01 conditional methodology: trailing 12-month average MDR, annualized. Cumulative default rate (NOT called CDR) retained for display only.
- **`compute_pool_assumptions()` requires `reconstruct_loan_timeline()`** on df_all first (for `default_month` and `payoff_month` columns used in conditional CDR).
- **CPR from Current March 2019 only.**
- **Loss severity is FIXED across all three scenarios** — only CDR and CPR shift.
- **All base/stress/upside defaults are cohort-specific**, not global averages.
- Projection starts at t=0 (March 2019), first payment at t=1 (April 2019).
- Pool-level aggregate projections only.
- Virtual environment named `.env`.
